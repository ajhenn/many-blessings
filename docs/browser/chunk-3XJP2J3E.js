import{i as M,j as K}from"./chunk-P5QJXQCF.js";import{$ as E,Ea as k,G as S,Y as q,Z as O,aa as C,d as D,fb as P,g as x,j as B,m as y,s as I}from"./chunk-2OOBEJUY.js";function g(u,c,w,e){return new Promise((n,r)=>{u||r("IndexedDB not available");let t=u.open(c,w),o;t.onsuccess=s=>{o=t.result,n(o)},t.onerror=s=>{r(`IndexedDB error: ${t.error}`)},typeof e=="function"&&(t.onupgradeneeded=s=>{e(s,o)})})}function $(u,c,w,e,n){return D(this,null,function*(){return new Promise((r,t)=>{if(!u)return;let o=u.open(c,w);o.onupgradeneeded=s=>D(null,null,function*(){let i=s.target.result,a=e.map(d=>D(null,null,function*(){if(!i.objectStoreNames.contains(d.store)){let l=i.createObjectStore(d.store,d.storeConfig);for(let f of d.storeSchema)l.createIndex(f.name,f.keypath,f.options)}}));yield Promise.all(a);let h=n&&n();if(h){let d=Object.keys(h).map(l=>parseInt(l,10)).filter(l=>l>s.oldVersion).sort((l,f)=>l-f);for(let l of d)h[l](i,o.transaction)}i.close(),r()}),o.onsuccess=s=>{s.target.result.close(),r()},o.onerror=s=>{t(s)}})})}function R(u,c,w){if(!u||!c||!w)throw Error('Params: "dbName", "version", "storeName" are mandatory.');return new x(e=>{try{let n=c+1,r=indexedDB.open(u,n);r.onupgradeneeded=t=>{let o=t.target.result;o.deleteObjectStore(w),o.close(),console.log("onupgradeneeded"),e.next(!0),e.complete()},r.onerror=t=>e.error(t)}catch(n){e.error(n)}})}function V(u,c){return u.objectStoreNames.contains(c)}function j(u,c,w){u||w("You need to use the openDatabase function to create a database before you query it!"),V(u,c)||w(`objectStore does not exists: ${c}`)}function b(u,c){let w=u.transaction(c.storeName,c.dbMode);return w.onerror=c.error,w.onabort=c.abort,w}function m(u,c,w,e){return{storeName:c,dbMode:u,error:n=>{w(n)},abort:n=>{w(n)}}}var p=function(u){return u.readonly="readonly",u.readwrite="readwrite",u}(p||{}),F=new E(null),G=(()=>{let c=class c{constructor(e,n){if(this.dbConfigs=e,this.platformId=n,this.defaultDatabaseName=null,this.isBrowser=K(this.platformId),this.isBrowser){this.indexedDB=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB;let r=Object.values(this.dbConfigs),t=r.length===1;for(let o of r)this.instanciateConfig(o,t)}}instanciateConfig(e,n){return D(this,null,function*(){if(!e.name)throw new Error("NgxIndexedDB: Please, provide the dbName in the configuration");if(!e.version)throw new Error("NgxIndexedDB: Please, provide the db version in the configuration");if((e.isDefault??!1)&&this.defaultDatabaseName)throw new Error("NgxIndexedDB: Only one database can be set as default");((e.isDefault??!1)&&!this.defaultDatabaseName||n)&&(this.defaultDatabaseName=e.name,this.selectedDb=e.name),yield $(this.indexedDB,e.name,e.version,e.objectStoresMeta,e.migrationFactory),g(this.indexedDB,e.name).then(r=>{r.version!==e.version&&(this.dbConfigs[e.name].version=r.version)})})}get dbConfig(){return this.dbConfigs[this.selectedDb]}getDatabaseVersion(){return new x(e=>{g(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(n=>{e.next(n.version),e.complete()}).catch(n=>e.error(`error during get version of database => ${n} `))})}selectDb(e){if(e=e??this.defaultDatabaseName,!e)throw new Error("No database name specified and no default database set.");if(!Object.keys(this.dbConfigs).includes(e))throw new Error(`NgxIndexedDB: Database ${e} is not initialized.`);this.selectedDb=e}createObjectStore(e,n){return D(this,null,function*(){let r=[e];yield $(this.indexedDB,this.dbConfig.name,++this.dbConfig.version,r,n)})}add(e,n,r){return new x(t=>{g(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(o=>{let i=b(o,m(p.readwrite,e,h=>t.error(h))).objectStore(e),a=r?i.add(n,r):i.add(n);a.onsuccess=h=>D(this,null,function*(){let d=h.target.result,l=i.get(d);l.onsuccess=f=>{t.next(f.target.result),t.complete()},l.onerror=f=>{t.error(f)}}),a.onerror=h=>{t.error(h)}}).catch(o=>t.error(o))})}bulkAdd(e,n){let r=new Promise((t,o)=>{g(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(s=>{let a=b(s,m(p.readwrite,e,t,o)).objectStore(e),h=n.map(d=>new Promise((l,f)=>{let v=d.key;delete d.key;let T=v?a.add(d,v):a.add(d);T.onsuccess=A=>{let L=A.target.result;l(L)}}));t(Promise.all(h))}).catch(s=>o(s))});return y(r)}bulkDelete(e,n){let r=n.map(t=>new Promise((o,s)=>{g(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(i=>{let a=b(i,m(p.readwrite,e,s,o));a.objectStore(e).delete(t),a.oncomplete=()=>{this.getAll(e).pipe(S(1)).subscribe(d=>{o(d)})}}).catch(i=>s(i))}));return y(Promise.all(r))}getByKey(e,n){return new x(r=>{g(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(t=>{let i=b(t,m(p.readonly,e,r.error)).objectStore(e).get(n);i.onsuccess=a=>{r.next(a.target.result),r.complete()},i.onerror=a=>{r.error(a)}}).catch(t=>r.error(t))})}bulkGet(e,n){let r=n.map(t=>this.getByKey(e,t));return new x(t=>{I(r).subscribe(o=>{t.next(o),t.complete()})})}getByID(e,n){return new x(r=>{g(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(t=>{j(t,e,a=>r.error(a));let i=b(t,m(p.readonly,e,r.error,r.next)).objectStore(e).get(n);i.onsuccess=a=>{r.next(a.target.result)}}).catch(t=>r.error(t))})}getByIndex(e,n,r){return new x(t=>{g(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(o=>{j(o,e,d=>t.error(d));let h=b(o,m(p.readonly,e,t.error)).objectStore(e).index(n).get(r);h.onsuccess=d=>{t.next(d.target.result),t.complete()}}).catch(o=>t.error(o))})}getAll(e){return new x(n=>{g(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(r=>{j(r,e,i=>n.error(i));let s=b(r,m(p.readonly,e,n.error,n.next)).objectStore(e).getAll();s.onerror=i=>{n.error(i)},s.onsuccess=({target:{result:i}})=>{n.next(i),n.complete()}}).catch(r=>n.error(r))})}update(e,n){return new x(r=>{g(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(t=>{j(t,e,a=>r.error(a));let s=b(t,m(p.readwrite,e,a=>r.error(a))).objectStore(e),i=s.put(n);i.onsuccess=a=>D(this,null,function*(){let h=a.target.result,d=s.get(h);d.onsuccess=l=>{r.next(l.target.result),r.complete()}})}).catch(t=>r.error(t))})}bulkPut(e,n){let r;return new x(t=>{g(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(o=>{j(o,e,i=>t.error(i)),r=b(o,m(p.readwrite,e,i=>t.error(i)));let s=r.objectStore(e);n.forEach((i,a)=>{let h=s.put(i);a===n.length-1&&(h.onsuccess=d=>{r.commit(),t.next(d.target.result),t.complete()}),h.onerror=d=>{r.abort(),t.error(d)}})}).catch(o=>{r?.abort(),t.error(o)})})}delete(e,n){return new x(r=>{g(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(t=>{j(t,e,i=>r.error(i));let o=b(t,m(p.readwrite,e,i=>r.error(i)));o.objectStore(e).delete(n),o.oncomplete=()=>{this.getAll(e).pipe(S(1)).subscribe(i=>{r.next(i),r.complete()})}}).catch(t=>r.error(t))})}deleteByKey(e,n){return new x(r=>{g(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(t=>{j(t,e,i=>r.error(i));let o=b(t,m(p.readwrite,e,i=>r.error(i))),s=o.objectStore(e);o.oncomplete=()=>{r.next(!0),r.complete()},s.delete(n)}).catch(t=>r.error(t))})}clear(e){return new x(n=>{g(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(r=>{j(r,e,s=>n.error(s));let t=b(r,m(p.readwrite,e,s=>n.error(s)));t.objectStore(e).clear(),t.oncomplete=()=>{n.next(!0),n.complete()}}).catch(r=>n.error(r))})}deleteDatabase(){return new x(e=>{g(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(n=>D(this,null,function*(){yield n.close();let r=this.indexedDB.deleteDatabase(this.dbConfig.name);r.onsuccess=()=>{e.next(!0),e.complete()},r.onerror=t=>e.error(t),r.onblocked=()=>{throw new Error("Unable to delete database because it's blocked")}})).catch(n=>e.error(n))})}openCursor(e,n,r="next"){return new x(t=>{g(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(o=>{j(o,e,h=>t.error(h));let i=b(o,m(p.readonly,e,t.error)).objectStore(e),a=n===void 0?i.openCursor():i.openCursor(n,r);a.onsuccess=h=>{t.next(h),t.complete()}}).catch(o=>t.error(o))})}openCursorByIndex(e,n,r,t="next",o=p.readonly){let s=new B;return g(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(i=>{j(i,e,f=>{s.error(f)});let l=b(i,m(o,e,f=>{s.error(f)},()=>{s.next()})).objectStore(e).index(n).openCursor(r,t);l.onsuccess=f=>{s.next(f)}}).catch(i=>s.error(i)),s}getAllByIndex(e,n,r){let t=[];return new x(o=>{g(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(s=>{j(s,e,l=>o.error(l));let d=b(s,m(p.readonly,e,o.error)).objectStore(e).index(n).openCursor(r);d.onsuccess=l=>{let f=l.target.result;f?(t.push(f.value),f.continue()):(o.next(t),o.complete())}}).catch(s=>o.error(s))})}getAllKeysByIndex(e,n,r){let t=[];return new x(o=>{g(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(s=>{j(s,e,l=>o.error(l));let d=b(s,m(p.readonly,e,o.error)).objectStore(e).index(n).openKeyCursor(r);d.onsuccess=l=>{let f=l.target.result;f?(t.push({primaryKey:f.primaryKey,key:f.key}),f.continue()):(o.next(t),o.complete())}}).catch(s=>o.error(s))})}count(e,n){return new x(r=>{g(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(t=>{j(t,e,a=>r.error(a));let i=b(t,m(p.readonly,e,r.error)).objectStore(e).count(n);i.onerror=a=>r.error(a),i.onsuccess=a=>{r.next(a.target.result),r.complete()}}).catch(t=>r.error(t))})}countByIndex(e,n,r){return new x(t=>{g(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(o=>{j(o,e,d=>t.error(d));let h=b(o,m(p.readonly,e,t.error)).objectStore(e).index(n).count(r);h.onerror=d=>t.error(d),h.onsuccess=d=>{t.next(d.target.result),t.complete()}}).catch(o=>t.error(o))})}deleteObjectStore(e){return R(this.dbConfig.name,++this.dbConfig.version,e)}};c.\u0275fac=function(n){return new(n||c)(C(F),C(k))},c.\u0275prov=q({token:c,factory:c.\u0275fac});let u=c;return u})(),Z=(()=>{let c=class c{static forRoot(...e){let n={};for(let r of e)Object.assign(n,{[r.name]:r});return{ngModule:c,providers:[G,{provide:F,useValue:n}]}}};c.\u0275fac=function(n){return new(n||c)},c.\u0275mod=P({type:c}),c.\u0275inj=O({imports:[M]});let u=c;return u})();var ee=(()=>{let c=class c{};c.DB_STORE_NAME="prayer",c.DB_FIELD_1="prayer",c.DB_FIELD_2="author",c.DB_FIELD_3="approved";let u=c;return u})();export{G as a,Z as b,ee as c};
